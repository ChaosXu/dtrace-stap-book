#!/usr/bin/env stap
/**
 * cfstrace.stp
 * 
 * Трассирует переключение процессов планировщиком CFS Linux
 * Использование: 
 *      сfstrace.stp CPU
 * 
 * Оттестировано на 2.6.32 (RedHat), 3.9
 */

/* Глобальные параметры */
global be_verbose = 1;
global print_stacks = 0;
global print_cfs_tree = 1;

global pnetime;
global cpetrace;

global trace_cpu;

global policy_names;

global cpu_cfs_rq;
global rq_curr;

/* get_task_se возвращает task_struct для se */
function get_task_se:long(se:long) {
    offset = &@cast(0, "struct task_struct")->se;    
    return se - offset;
}

/* get_task_se возвращает sched_entity для task */
function get_se_task:long(task:long) {
    offset = &@cast(0, "struct task_struct")->se;
    return task +  offset;
}

/* get_rb_se возвращает sched_entity для rb */
function get_rb_se:long(rb:long) {
    offset = &@cast(0, "struct sched_entity")->run_node;
    return rb - offset;
}

/* возвращает строку, соответствующую задаче t */
function sprint_task(t:long) {
    policy = @cast(t, "struct task_struct")->policy;
    return sprintf("t: %p %s/%d %s se: %p", t, task_execname(t), task_tid(t),
                    policy_names[policy], get_se_task(t));
}

function sprint_cfs_rq_path(cfs_rq:long) {
    tg = @cast(cfs_rq, "struct cfs_rq")->tg;        
    if(!tg)
        return "???";

%( CONFIG_SCHED_AUTOGROUP == "y"
%?
    if(@cast(tg, "struct task_group")->autogroup) {
        return sprintf("/autogroup-%d", 
                       @cast(tg, "struct task_group")->autogroup->id);
    }
%)

    cgroup = @cast(tg, "struct task_group")->css->cgroup;
    
    try {
        return reverse_path_walk(@cast(cgroup, "struct cgroup")->dentry);
    }
    catch {
        return "/???";
    }
}   

/* Выводит информацию о сущности планирования se */
function print_se(s:string, se:long, verbose:long) {
    printf("\tse:%8s ", s);
    
    my_q = @cast(se, "struct sched_entity")->my_q;
    
    if(my_q == 0) {    
        println(sprint_task(get_task_se(se)));
    }
    else {
        printf("se: %p my_q: %p %s", se, my_q, sprint_cfs_rq_path(my_q));
    }
    
    if(verbose) {
        printf("\t\tload.weight: %d load.inv_weight: %d exec_start: %d vruntime: %d sum_exec_runtime: %d\n",
                    @cast(se, "struct sched_entity")->load->weight,
                    @cast(se, "struct sched_entity")->load->inv_weight,
                    @cast(se, "struct sched_entity")->exec_start,
                    @cast(se, "struct sched_entity")->vruntime,
                    @cast(se, "struct sched_entity")->sum_exec_runtime);
        if(@defined(@cast(se, "struct sched_entity")->avg)) {
            printf("\t\tavg: runnable_avg_sum: %d runnable_avg_period: %d \n",
                        @cast(se, "struct sched_entity")->avg->runnable_avg_sum,
                        @cast(se, "struct sched_entity")->avg->runnable_avg_period);
            printf("\t\tavg: load_avg_contrib: %d decay_count: %d\n",
                        @cast(se, "struct sched_entity")->avg->load_avg_contrib,
                        @cast(se, "struct sched_entity")->avg->decay_count);
        }
    }
}

/* Выводит информацию об очереди cfs_rq */
function print_cfs_rq(cfs_rq:long, verbose:long) {
    firstrb = @cast(cfs_rq, "struct cfs_rq")->rb_leftmost;
    skip = @cast(cfs_rq, "struct cfs_rq")->skip;
    last = @cast(cfs_rq, "struct cfs_rq")->last;
    nextse = @cast(cfs_rq, "struct cfs_rq")->next;
    
    printf("\tCFS_RQ: %s\n", sprint_cfs_rq_path(cfs_rq));

    if(verbose) {
        printf("\t\tnr_running: %d load.weight: %d load.inv_weight: %d \n",
            @cast(cfs_rq, "struct cfs_rq")->nr_running, 
            @cast(cfs_rq, "struct cfs_rq")->load->weight,
            @cast(cfs_rq, "struct cfs_rq")->load->inv_weight);
        if(@defined(@cast(cfs_rq, "struct cfs_rq")->runnable_load_avg)) {
            printf("\t\trunnable_load_avg: %d blocked_load_avg: %d \n",
                @cast(cfs_rq, "struct cfs_rq")->runnable_load_avg, 
                @cast(cfs_rq, "struct cfs_rq")->blocked_load_avg);
        }
        else {
            printf("\t\tload_avg: %d\n",
                @cast(cfs_rq, "struct cfs_rq")->load_avg);
        }
    }
    
    if(firstrb) {
        firstse = get_rb_se(firstrb);
        print_se("first", firstse, verbose);
    }
    
    if(skip)
        print_se("skip", skip, 0);
    if(last)
        print_se("last", last, 0);
    if(nextse)
        print_se("next", nextse, 0);
}

function dump_cfs_rq_rb(indstr:string, rb:long, verbose:long) {
    left  = @cast(rb, "struct rb_node")->rb_left;
    right = @cast(rb, "struct rb_node")->rb_right;
    
    print_se(sprintf("%s:", indstr), get_rb_se(rb), verbose);
    
    if(left)
        dump_cfs_rq_rb(sprintf("%s-l", indstr), left, verbose);
    if(right)
        dump_cfs_rq_rb(sprintf("%s-r", indstr), right, verbose);
}

/* Выводит дерево tasks_timeline очереди cfs_rq */
function dump_cfs_rq(cfs_rq:long, verbose:long) {
    root = @cast(cfs_rq, "struct cfs_rq")->tasks_timeline->rb_node;
    
    dump_cfs_rq_rb("rb", root, verbose);
}

probe begin {
    pnetime = local_clock_ns();
    cpu_cfs_rq = 0;
    rq_curr = 0;

    trace_cpu = $1;

    printf("Tracing CPU%d...\n", trace_cpu);

    policy_names[0] = "SCHED_NORMAL";   policy_names[1] = "SCHED_FIFO";
    policy_names[2] = "SCHED_RR";       policy_names[3] = "SCHED_BATCH";
    policy_names[4] = "SCHED_ISO";      policy_names[5] = "SCHED_IDLE";
}

probe kernel.function("pick_next_task_fair") {
    if(cpu() != trace_cpu) next;
    
    pnetime2 = local_clock_ns();
    printf("=> pick_next_task_fair D=%d J=%d\n", pnetime2 - pnetime, $jiffies);
    
    if(print_stacks)
        print_backtrace();
    
    pnetime = pnetime2;
    cpu_cfs_rq = &$rq->cfs;
}

probe kernel.function("pick_next_task_fair").return {
    if(cpu() != trace_cpu) next;
    
    printf("<= pick_next_task_fair\n");

    if($return != 0) {
        se = &$return->se;
        print_se("sched", se, 0);
    }
    
    println("");
    cpu_cfs_rq = 0;
}

probe kernel.function("pick_next_entity") {    
    if(cpu() != trace_cpu || cpu_cfs_rq == 0) next;
    
    printf("\tpick_next_entity\n");
    print_cfs_rq(cpu_cfs_rq, be_verbose);
    
    if(print_cfs_tree)
        dump_cfs_rq(cpu_cfs_rq, be_verbose);
}

probe kernel.function("task_tick_fair") {  
    if(cpu() != trace_cpu) next;

    printf("=> task_tick_fair J=%d queued: %d curr: %s\n", $jiffies, $queued, sprint_task($curr));

    rq_curr = get_se_task($curr);
    cpu_cfs_rq = &$rq->cfs;
}

probe kernel.function("sched_slice").return {
    if(cpu() != trace_cpu) next;

    printf("\tsched_slice: %d\n", $return);
}

probe kernel.function("check_preempt_tick") {
    if(cpu() != trace_cpu || rq_curr == 0 || cpu_cfs_rq == 0) next;
    
    print_se("curr", rq_curr, be_verbose);
    printf("\t\tdelta_exec: %d\n", 
            @cast(rq_curr, "struct sched_entity")->sum_exec_runtime - 
            @cast(rq_curr, "struct sched_entity")->prev_sum_exec_runtime);
    
    firstrb = @cast(cpu_cfs_rq, "struct cfs_rq")->rb_leftmost;
    if(firstrb) {
        firstse = get_rb_se(firstrb);
        printf("\t\tdelta: %d", 
            @cast(rq_curr, "struct sched_entity")->vruntime - 
            @cast(firstse, "struct sched_entity")->vruntime);
    }
}

probe kernel.function("task_tick_fair").return {
    if(cpu() != trace_cpu) next;

    cpu_cfs_rq = 0;
    rq_curr = 0;

    println("<= task_tick_fair");
}

probe kernel.function("wakeup_preempt_entity") {                                                                                                                                              
    if(cpu() != trace_cpu || rq_curr == 0 || cpetrace == 0) next;
                                                                                                                                                                                                                                                                                                                                                                           
    vdiff = @cast(rq_curr, "struct sched_entity")->vruntime - $se->vruntime;                                                                                                                                                   
                                                                                                                                                                                              
    printf("\twakeup_preempt_entity: vdiff: %d\n", vdiff);      
}  

probe kernel.function("check_preempt_wakeup") {
    if(cpu() != trace_cpu) next;
    cpetrace = 1;

    t_curr = task_current();
    t_se = $p;

    println("=> check_preempt_wakeup:");
    printf("\tcurr: %s\n", sprint_task(t_curr));
    printf("\tse: %s\n", sprint_task(t_se));
    
    if(print_stacks)
        print_backtrace();
}

probe kernel.function("check_preempt_wakeup").return {
    if(cpu() != trace_cpu) next;

    cpetrace = 0;
    
    printf("<= check_preempt_wakeup\n\n");
}

probe kernel.function("resched_task") {
    if(cpu() != trace_cpu || cpetrace == 0) next;
    
    if(@defined($p)) 
       task_string = sprint_task($p)
    else 
       task_string = "???";
    
    printf("\tresched_task %s\n", task_string);
}
