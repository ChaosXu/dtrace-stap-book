<html>
<head>
	<meta charset="utf-8" /> 
	<meta http-equiv="Content-Type" content="text/html">
	<meta name="generator" content="TSDoc 0.2">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<title>Module 5: Application tracing</title>
	
	<link rel="stylesheet" href="../bootstrap/css/bootstrap.css" />
	<link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet" media="screen,handheld"/>
	
	<script type="text/javascript">
	function toggleCode(id) {
		code = document.getElementById(id);
		hideClass = 'hide';
		
		if(code.classList.contains(hideClass))
			code.classList.remove(hideClass);
		else
			code.classList.add(hideClass);
	}
	</script>
</head>
<body>

<!-- HEADER -->

<div class="navbar">
    <div class="navbar-inner">
	    <div class="container">
			<a class="brand" href="../index.html">Dynamic Tracing with DTrace & SystemTap</a><ul class="nav pull-left">
<li><a href="proc.html"><strong>Prev</strong>(Userspace process tracing)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="ex6.html"><strong>Next</strong>(Exercise 6)</a></li>
</ul>
		</div>
    </div>
</div>

<div class="container max-height no-overflow">
	<div id="content" nevow:render="content">
		<p>
<h3>Unix C library</h3></p>
<p>
<em>libc</em> is a C library shipped with Unix which provides access to most of its facilities like system calls in a portable manner. Linux <em>glibc</em> (one of the implementations of <em>libc</em> which is most popular) and <em>libc</em> shipped with Solaris contain some USDT probes. We will discuss them in this section. <br /></p>
<p>
On Solaris USDT probes are limited to userspace mutexes and read-write locks which available as <code>plockstat</code> provider (similar to <a href="../kernel/async.html#lockstat">lockstat</a> provider we discussed earlier). <em>glibc</em>, however implements wider set of probes: along with various <em>pthread</em> operations which include not only mutexes and rwlocks but also condition variables and threads operations, it supports tracing of <code>setjmp</code>/<code>longjmp</code> and dynamic linker <code>ld.so</code>.<br /></p>
<p>
Lets see how mutexes are traced in Solaris and Linux (in this section we will assume glibc by saying "Linux"). Solaris provides them through <code>plockstat</code> provider:<br /></p>
<p>
<pre>
plockstat<i>pid</i>:::<i>probe-name</i> 
</pre>
</p>
<p>
SystemTap will use standard USDT notation for it:<br /></p>
<p>
<pre>
probe process("libpthread.so.0").mark("<i>probe-name</i>")
</pre>
</p>
<p>
Note that <code>libpthread.so.0</code> will vary in different distributions. We will use macro-definitions for paths in our scripts. <br /></p>
<p>
Userspace programs have to explicitly ask kernel to block thread that is waiting on condition variable or mutex. Linux provides <code>futex</code> system call for it which is wrapped into so-called <em>low-level-locks</em> in glibc (they are seen by probes those name start with <code>lll</code>). Solaris provides multiple <code>lwp_*</code> system calls for it like <code>lwp_park</code> which "parks" thread (stops its execution).<br /></p>
<p>
Here are list of probes available for userspace mutexes (use them as probe name). First argument (<code>arg0</code> in DTrace or <code>$arg1</code> in SystemTap) would be address of pthread mutex. Some probes can contain more arguments, i.e. DTrace will pass number of spinning loops to <code>mutex-spun</code> probe. Check documentation for them.<br /></p>
<p>
    <table class="table table-bordered">
        <tr>
            <td>
<strong>Action</strong></td>
            <td>
<strong>DTrace</strong></td>
            <td>
<strong>SystemTap</strong></td>
</tr>
        <tr>
            <td>
Creation                </td>
            <td>
 -                   </td>
            <td>
<code>mutex_init</code></td>
</tr>
        <tr>
            <td>
Destruction             </td>
            <td>
 -                   </td>
            <td>
<code>mutex_destroy</code></td>
</tr>
        <tr>
            <td>
Attempt to acquire      </td>
            <td>
 -                   </td>
            <td>
<code>mutex_entry</code></td>
</tr>
        <tr>
            <td>
Busy waiting (spinning) </td>
            <td>
<code>mutex-spin</code><br /><code>mutex-spun</code></td>
            <td>
 -</td>
</tr>
        <tr>
            <td>
Attempt to block        </td>
            <td>
<code>mutex-block</code></td>
            <td>
<code>lll_lock_wait</code></td>
</tr>
        <tr>
            <td>
Acquired mutex          </td>
            <td>
<code>mutex-blocked</code><br /><code>mutex-acquire</code><br /><code>mutex-error</code></td>
            <td>
<code>mutex_release</code><br /><code>lll_futex_wake</code></td>
</tr>
        <tr>
            <td>
</td>
</tr>
</table>
</p>
<p>
Here are an example of pthread tracer in SystemTap:<br /></p>
<p>
<div class="well">
<button class="btn" onclick="toggleCode('code140085534448016')">+</button>&nbsp; Script file pthread.stp <br/><p>
<pre id="code140085534448016" class="hide">
#!/usr/bin/env stap

@define libpthread %( "/lib64/libpthread.so.0" %)
@define libc %( "/lib64/libc.so.6" %)

probe process(@libpthread).mark("pthread_create") {
    if(pid() != target()) next;

    thread_id = user_long($arg1);
    thread_caller = usymname($arg3);
    thread_arg = $arg4;
    
    printf("[%d] pthread_create %x %s(%x)\n", tid(),
            thread_id, thread_caller, thread_arg);
}

probe process(@libpthread).mark("pthread_start") {
    if(pid() != target()) next;

    thread_id = $arg1;
    printf("[%d] pthread_start %x\n", tid(), thread_id);
}

probe process(@libpthread).mark("pthread_join") {
    if(pid() != target()) next;

    thread_id = $arg1;
    printf("[%d] pthread_join %x\n", tid(), thread_id);
}

probe process(@libpthread).mark("pthread_join_ret") {
    if(pid() != target()) next;

    thread_id = $arg1;
    printf("[%d] pthread_join %x return -> %d/%d \n", tid(),
            thread_id, $arg2, $arg3);
}

probe process(@libpthread).mark("mutex_*"),
      process(@libpthread).mark("cond_*"),
      process(@libpthread).mark("rdlock_*"),
      process(@libpthread).mark("wrlock_*"),
      process(@libpthread).mark("rwlock_*") {
    if(pid() != target()) next;

    printf("[%d] %s %p\n", tid(), pn(), $arg1);
    print_ustack(ucallers(5));
}

probe process(@libpthread).mark("lll_*"),
      process(@libc).mark("lll_*") {
    if(pid() != target()) next;

    printf("[%d] %s\n", tid(), pn());
    print_ustack(ucallers(5));
}
</pre>
</p>
</div>
</p>
<p>
If we set tsexperiment process as a target, we can see how request is passed from control thread to a worker thread (some output is omitted):<br /></p>
<p>
<pre>
[8972] process("/lib64/libpthread.so.0").mark("mutex_entry") 0xe1a218
  0x7fbcf890fa27 : tpd_wqueue_put+0x26/0x6a [/opt/tsload/lib/libtsload.so]
[8972] process("/lib64/libpthread.so.0").mark("mutex_acquired") 0xe1a218
 0x7fbcf890fa27 : tpd_wqueue_put+0x26/0x6a [/opt/tsload/lib/libtsload.so]
[8972] process("/lib64/libpthread.so.0").mark("cond_broadcast") 0xe1a240
[8972] process("/lib64/libpthread.so.0").mark("mutex_release") 0xe1a218
 0x7fbcf890fa27 : tpd_wqueue_put+0x26/0x6a [/opt/tsload/lib/libtsload.so]
[8971] process("/lib64/libpthread.so.0").mark("mutex_entry") 0xe1a628
 0x7fbcf9148fed : cv_wait+0x2d/0x2f [/opt/tsload/lib/libtscommon.so]
 0x7fbcf890f93f : tpd_wqueue_pick+0x44/0xbc [/opt/tsload/lib/libtsload.so]
[8971] process("/lib64/libpthread.so.0").mark("mutex_acquired") 0xe1a628
</pre>
</p>
<p>
Note that thread with TID=8972 will acquire mutex in <code>tpd_wqueue_put</code> function and then send a broadcast message to all workers. One of them (one with TID=8971) wakes up, re-acquires mutex and gets request through <code>tpd_wqueue_pick</code>. <br /></p>
<p>
<code>plockstat</code> doesn't support many probes that glibc do, put we can easily replace them with <code>pid</code> provider and function boundary tracing:<br /></p>
<p>
<div class="well">
<button class="btn" onclick="toggleCode('code140085534448592')">+</button>&nbsp; Script file pthread.d <br/><p>
<pre id="code140085534448592" class="hide">
#!/usr/bin/dtrace
#pragma D option bufsize=8m
#pragma D option switchrate=100hz

pid$target::pthread_create:entry {
    self->thread_id_ptr = (uintptr_t) arg0;
    self->thread_func = arg2;
    self->thread_arg = arg3;
}
pid$target::pthread_create:return {
    this->thread_id = * (uint_t*) copyin(self->thread_id_ptr, sizeof(uint_t));
    printf("[%d] pthread_create %x ", tid, this->thread_id);
    usym(self->thread_func);
    printf("(%x)\n", self->thread_arg);
}
pid$target::pthread_join:entry {
    self->thread_id = (uint_t) arg0;
    printf("[%d] pthread_join %x\n", tid, self->thread_id);
}
pid$target::pthread_join:return {
    printf("[%d] pthread_join:return %x -> %d\n", tid, self->thread_id, arg1);
}

plockstat$target:::, 
pid$target::pthread_cond_*wait*:entry,
pid$target::pthread_cond_*wait*:return,
pid$target::pthread_cond_signal:entry,
pid$target::pthread_cond_broadcast:entry {
    printf("[%d] %s:%s ", tid, probefunc, probename);
    usym(arg0);
    printf("[%p]\n", arg0);
    ustack(6);
}</pre>
</p>
</div>
</p>
<p>
That script yields similar results on Solaris:<br /></p>
<p>
<pre>
[7] mutex_lock_impl:mutex-acquire   0x46d4a0                        [46d4a0]
              libtsload.so`tpd_wqueue_put+0x26
[7] cond_signal:entry   0x46d4e0                                    [46d4e0]
[7] mutex_unlock_queue:mutex-release   0x46d4a0                     [46d4a0]
[7] mutex_unlock_queue:mutex-release   0x46d4a0                     [46d4a0]
[6] mutex_lock_impl:mutex-acquire   0x46d4a0                        [46d4a0]
              libtsload.so`tpd_wqueue_pick+0xb6
[6] pthread_cond_wait:return   0x15                                 [15]
</pre>
</p>
<p>
<h4>References</h4></p>
<p>
    <ul>
        <li>
<a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=nptl/DESIGN-systemtap-probes.txt">glibc documentation on SystemTap probes</a></li>
        <li>
<img src="../images/icons/dtrace.png" alt="" class="img-rounded"/><a href="http://docs.oracle.com/cd/E19253-01/817-6223/chp-plockstat/index.html">plockstat Provider</a></li>
</ul>
</p>

	</div>
</div>

<!-- TAIL -->

<div class="navbar navbar-bottom">
    <div class="navbar-inner">
        <div class="container">
            <ul class="nav pull-left">
<li><a href="proc.html"><strong>Prev</strong>(Userspace process tracing)</a></li>
</ul>
<ul class="nav pull-center">
<li><a href="../index.html"><strong>Up</strong>(Dynamic Tracing with DTrace & SystemTap)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="ex6.html"><strong>Next</strong>(Exercise 6)</a></li>
</ul>
        </div>
    </div>
</div>

<ul class="breadcrumb">
    <li><a href="https://github.com/myaut/dtrace-stap-book"><small>GitHub</small></a> <span class="divider">|</span></li>
    <li><a href="https://bitbucket.org/sergey_klyaus/dtrace-stap-book"><small>BitBucket</small></a> <span class="divider">|</span></li>
    <li style="float: right; ">
        <small>
        Published under terms of <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC-BY-NC-SA 3.0</a> license.
        </small>
    </li>
</ul>
</body>
</html>