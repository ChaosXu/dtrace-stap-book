<html>
<head>
	<meta charset="utf-8" /> 
	<meta http-equiv="Content-Type" content="text/html">
	<meta name="generator" content="TSDoc 0.2">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<title> Module 3: Principles of dynamic tracing
</title>
	
	<link rel="stylesheet" href="../bootstrap/css/bootstrap.css" />
	<link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet" media="screen,handheld"/>
	
	<script type="text/javascript">
	function toggleCode(id) {
		code = document.getElementById(id);
		hideClass = 'hide';
		
		if(code.classList.contains(hideClass))
			code.classList.remove(hideClass);
		else
			code.classList.add(hideClass);
	}
	</script>
	
	<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-71659121-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>
<body>

<!-- HEADER -->

<div class="navbar">
    <div class="navbar-inner">
	    <div class="container">
			<a class="brand" href="../index.html">Dynamic Tracing with DTrace & SystemTap</a><ul class="nav pull-left">
<li><a href="profiling.html"><strong>Prev</strong>(Profiling)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="prepost.html"><strong>Next</strong>(Pre- and post-processing)</a></li>
</ul>
		</div>
    </div>
</div>

<div class="container max-height no-overflow">
	<div id="content" nevow:render="content">
		<h3>
 Performance analysis</h3>
<p>
Computer users, system administrators and developers are interested in improving of performance of computer systems and dynamic tracing languages are very handful in analysing soft spots of computer systems. We will use two characteristics of computer system to evaluate its performance most of the time: <em>throughput</em> and time spent for servicing request (usually referred as <em>latency</em>). These two characteristics depend on each other as following picture shows:</p>
<p>
<img src="../images/perf.png" alt="" class="img-rounded"/></p>
<p>
<span class="label label-info">Information</span>    <div class="well">
        <p>
For example, let's imagine a newspaper kiosk. Than number of customers per hour will be its <em>arrival rate</em>. Sometimes, when clerk is busy while servicing customer, other customers will form a queue, which can is measurable to <em>queue length</em>. Growing queues is a sign of the system's <em>saturation</em>. <em>Throughput</em> of the kiosk is the number of customers which bought a newspaper per hour. However, if number of customers is too large, kiosk couldn't service them all, and some of them will leave after waiting in line -- they are treated as <em>errors</em>. When kiosk reaches its saturation point or the <em>knee</em>, <em>throughput</em> of the kiosk will fall, and number of errors will increase, because clerk will be tired. </p>
        <p>
<em>Latency</em> consists of <em>service time</em> which depends on many factors: i.e. if customer need change or clerk can't find copy of newspaper it will grow,  and <em>waiting time</em> -- time spent by a customer waiting in queue. <em>Utilization</em> is defined by a fraction time that clerk spends servicing their customers. I.e. if clerk spends 15 minutes to sell a magazines or newspapers per hour, utilization is 25%. </p>
        <p>
These definitions are part of <em>queueing theory</em> which was applied to telephone exchange, but it is also applicable to computer systems. Either network packet or block input-output operations may be considered as <em>request</em>, while corresponding driver and device are considered as <em>servers</em>. In our kiosk example, customer were the requests while clerk at the kiosk was the server.
</p>
</div>
</p>
<p>
To measure throughput we have to attach a probe to one of the functions responsible for handling requests, and use <code>count()</code> aggregation in it. It is preferable to use the last function responsible for that, because it will improve data robustness. Using a timer, we will print the aggregation value and clear it. For example, throughput of disk subsystem may be measured using following SystemTap script:</p>
<p>
    <p>
    <pre>
# stap -e ' global io; 
    probe ioblock.end { 
        size = 0
        for(vi = 0; vi < $bio->bi_vcnt; ++vi)
            size += $bio->bi_io_vec[vi]->bv_len;
        io[devname] <<< size
    } 
    probe timer.s(1) { 
        foreach(devname in io) { 
            printf("%8s %d\n", devname, @sum(io[devname])); 
        } 
        delete io; 
    }'</pre>
</p>
</p>
<p>
Or with DTrace:
    <p>
    <pre>
# dtrace -n '
    io:::done { 
        @[args[1]->dev_statname] = sum(args[0]->b_bcount); 
    } 
    tick-1s { 
        printa(@); 
        clear(@); 
    }'</pre>
</p>
</p>
<p>
To measure <em>arrival rate</em>, on contrary, we need first functions which handle request "arrival" which are in our case <code>ioblock.request</code> and <code>io:::start</code> correspondingly. These probes will be covered in <a href="../kernel/bio.html">Block Input-Output</a> section.</p>
<p>
<a name="latency"></a>
Latency measurement is a bit more complicated. We will need to add probes to request arrival and final handler and calculate time difference between these two moments. So we need to save a timestamp of a request arrival and retrieve it at the final handler probe. The easiest way to do that is thread-local variables, but it is not guaranteed that final handler will be called from same context request was created from. For example, final handler may be called from IRQ handler thread. In such cases we will need associative arrays and a unique request key retrievable on both sides, which is usually an address of requests descriptor in memory. For block input-output is <code>struct buf</code> in Solaris and <code>struct bio</code> in Linux. So let's calculate mean latency in SystemTap:
    <p>
    <pre>
# stap -e ' global start, times;    
    probe ioblock.request { 
        start[$bio] = gettimeofday_us();
    }
    probe ioblock.end { 
        if(start[$bio] != 0)
            times[devname] <<< gettimeofday_us() - start[$bio];
        delete start[$bio];
    }
    probe timer.s(1) {
        printf("%12s %8s %s\n", "DEVICE", "ASVC_T", ctime(gettimeofday_s()));
        
        foreach([devname] in times) {
            printf("%12s %8d\n", devname, @avg(times[devname]));
        }
        delete times;
    }'</pre>
</p>
</p>
<p>
Similar script is for DTrace:
    <p>
    <pre>
# dtrace -qn '
    io:::start { 
        iostart[arg0] = timestamp; 
    }
    io:::done {
        @rq_svc_t[args[1]->dev_statname] = avg(timestamp - iostart[arg0]);
    }
    tick-1s {
        printf("%12s %8s %Y\n", "DEVICE", "ASVC_T", walltimestamp);
        printa("%12s %@8d\n", @rq_svc_t);
        clear(@rq_svc_t);
    } '</pre>
</p>
</p>
<p>
Utilization may be measured similar to a profiling: high-resolution timer determines if server is busy or not, so utilization will be busy ticks to all ticks ratio. Queue length may be modelled from arrival rate and dispatch rate, but in many cases it is explicitly accessible from kernel or application data.</p>
<p>
</p>

	</div>
</div>

<!-- TAIL -->

<div class="navbar navbar-bottom">
    <div class="navbar-inner">
        <div class="container">
            <ul class="nav pull-left">
<li><a href="profiling.html"><strong>Prev</strong>(Profiling)</a></li>
</ul>
<ul class="nav pull-center">
<li><a href="../index.html"><strong>Up</strong>(Dynamic Tracing with DTrace & SystemTap)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="prepost.html"><strong>Next</strong>(Pre- and post-processing)</a></li>
</ul>
        </div>
    </div>
</div>

<ul class="breadcrumb">
    <li><a href="https://github.com/myaut/dtrace-stap-book"><small>GitHub</small></a> <span class="divider">|</span></li>
    <li><a href="https://bitbucket.org/sergey_klyaus/dtrace-stap-book"><small>BitBucket</small></a> <span class="divider">|</span></li>
    <li style="float: right; ">
        <small>
        Published under terms of <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC-BY-NC-SA 3.0</a> license.
        </small>
    </li>
</ul>
</body>
</html>