<html>
<head>
	<meta charset="utf-8" /> 
	<meta http-equiv="Content-Type" content="text/html">
	<meta name="generator" content="TSDoc 0.2">
	
	<title>Introduction</title>
	
	<link rel="stylesheet" href="../bootstrap/css/bootstrap.css" />
	<link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet" />
	
	<script type="text/javascript">
	function toggleCode(id) {
		code = document.getElementById(id);
		hideClass = 'hide';
		
		if(code.classList.contains(hideClass))
			code.classList.remove(hideClass);
		else
			code.classList.add(hideClass);
	}
	</script>
</head>
<body>

<!-- HEADER -->

<div class="navbar">
    <div class="navbar-inner">
	    <div class="container">
			<a class="brand" href="../index.html">Dynamic Tracing with DTrace & SystemTap</a><ul class="nav pull-left">
<li><a href="foreword.html"><strong>Prev</strong>(Foreword)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="oskernel.html"><strong>Next</strong>(Operating system Kernel)</a></li>
</ul>
		</div>
    </div>
</div>

<div class="container max-height no-overflow">
	<div id="content" nevow:render="content">
		<p>
<h3>TSLoad workload generator</h3></p>
<p>
During this course we will need to demonstrate created scripts on a real system. We will use version 0.2 of TSLoad workload generator to do so. Its <a href="http://myaut.github.io/tsload/">documentation</a> and <a href="https://github.com/myaut/tsload">source code</a> are available on GitHub.<br /></p>
<p>
Experiment configuration files are kept in JSON format: each experiment starts with directory with <code>experiment.json</code> file in it (it can also be accompanied by traces and timeseries). This file contains description of threadpools and workloads: their types and parameters. <br /></p>
<p>
<div class="well">
<button class="btn" onclick="toggleCode('code140460563686864')">+</button>&nbsp; Script file experiment.json <br/><p>
<pre id="code140460563686864" class="hide">
{   "name": "jump_table",
    "steps": {
        "jt": {
            "num_steps":    100,
            "num_requests": 2000 } 
    },
    "threadpools": {
        "tp_jt" : {
            "num_threads": 24,
            "quantum": 2000000000,
            "disp": { "type": "round-robin" } } 
    },
    "workloads" : {
        "jt" : {
            "wltype": "jt",
            "threadpool": "tp_jt",
            "params": {
                "num_request_types": 5000,
                "request_type": {
                    "randgen": { "class": "lcg" } },
                "is_incorrect": {
                    "randgen": { "class": "lcg" },
                    "pmap": [
                        { "probability": 0.2, "value": true },
                        { "probability": 0.8, "value": false }
                    ] } },
            "rqsched": {
                "type": "iat",
                "distribution": "exponential"
            } 
        } 
    } 
}</pre>
</p>
</div>
</p>
<p>
For example, <a name="ref:experiment.json"></a> defines an experiment called <code>jump_table</code>. <code>workloads</code> section defines workload <code>jt</code> which type is also <code>jt</code>. That workload have the following parameters:<br /></p>
<p>
    <ul>
        <li>
<code>num_request_types</code> - set globally for entire workload - number of "request types" that will be generated;<br />   </li>
        <li>
<code>request_types</code> - generated for each request with linear congruential PRNG;<br />   </li>
        <li>
<code>is_incorrect</code> - boolean value which will be set to true for 20% requests.<br /></li>
</ul>
</p>
<p>
It also defines <em>request scheduler</em> -- inter arrival time will be generated using exponential distribution. <code>steps</code> section defines number of requests which will be generated for this workload: 100 steps with 2000 requests in each.<br /></p>
<p>
<code>threadpools</code> section defines threadpools which will perform our workloads. It defines pool <code>tp_jt</code> which contains 24 threads with step period set to 2 second (as paramter <code>quantum</code> sets in nanoseconds). <em>Threadpool dispatcher</em> describes how requests will be distributed across threads and it is set to round-robin. <br /></p>
<p>
If we try to draw a timing diagram of the requests generated by this configuration file we will get something like <a name="image:tsload"></a>.<br /></p>
<p>
<img src="../images/tsload.png" alt="" /></p>
<p>
<code>jt</code> workload type is defined in a separate loadable module which contains code for simulating requests. During our book we meet similar modules in exercises: <code>proc_starter</code> which forks processes, <code>file_opener</code> which randomly opens files and other modules.<br /></p>
<p>
Experiment is started with <code>tseexperiment</code> command:<br /></p>
<p>
<pre>
# tsexperiment -e /path/to/experiment run
</pre>
</p>
<p>
In this command <code>/path/to/experiment</code> is a directory which contains file <code>experiment.json</code>. That directory will also contain experiment results which can be listed with <code>list</code> subcommand of <code>tseexperiment</code>:<br /></p>
<p>
<pre>
# tsexperiment -e /path/to/experiment list
</pre>
</p>
<p>
Results may be exported to CSV format with <code>export</code> subcommand or some statistics may be shown with <code>report</code> subcommand.<br /></p>
<p>
It is not necessary to edit configuration file each time parameter have to be altered: <code>run</code> subcommand has <code>-s</code> option. To provide its argument, check flattened names of configuration parameters with <code>-l</code> option of subcommand <code>show</code>:<br /></p>
<p>
<pre>
# tsexperiment -e /opt/tsload/var/tsload/mbench/jt show -l
name=jump_table
steps:jt:num_steps=100
steps:jt:num_requests=2000
...
</pre>
</p>
<p>
So, to change number of per-step requests to 500, you should call <code>tsexperiment</code> with following options:<br /></p>
<p>
<pre>
# tsexperiment -e /opt/tsload/var/tsload/mbench/jt run  \
    -s steps:jt:num_requests=500
</pre>
</p>
<p>
In some cases we will need to use hardware device names in experiment configuration, i.e. to bind threads to CPU cores. To get their names, run <code>tshostinfo</code> command:<br /></p>
<p>
<pre>
tshostinfo -x
</pre>
</p>

	</div>
</div>

<!-- TAIL -->

<div class="navbar">
    <div class="navbar-inner">
        <div class="container">
            <ul class="nav pull-left">
<li><a href="foreword.html"><strong>Prev</strong>(Foreword)</a></li>
</ul>
<ul class="nav pull-center">
<li><a href="../index.html"><strong>Up</strong>(Dynamic Tracing with DTrace & SystemTap)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="oskernel.html"><strong>Next</strong>(Operating system Kernel)</a></li>
</ul>
        </div>
    </div>
</div>

</body>
</html>