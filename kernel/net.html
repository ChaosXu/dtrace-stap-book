<html>
<head>
	<meta charset="utf-8" /> 
	<meta http-equiv="Content-Type" content="text/html">
	<meta name="generator" content="TSDoc 0.2">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<title> Module 4: Operating system kernel tracing
</title>
	
	<link rel="stylesheet" href="../bootstrap/css/bootstrap.css" />
	<link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet" media="screen,handheld"/>
	
	<script type="text/javascript">
	function toggleCode(id) {
		code = document.getElementById(id);
		hideClass = 'hide';
		
		if(code.classList.contains(hideClass))
			code.classList.remove(hideClass);
		else
			code.classList.add(hideClass);
	}
	</script>
	
	<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-71659121-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>
<body>

<!-- HEADER -->

<div class="navbar">
    <div class="navbar-inner">
	    <div class="container">
			<a class="brand" href="../index.html">Dynamic Tracing with DTrace & SystemTap</a><ul class="nav pull-left">
<li><a href="ex5.html"><strong>Prev</strong>(Exercise 5)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="sobj.html"><strong>Next</strong>(Synchronization primitives)</a></li>
</ul>
		</div>
    </div>
</div>

<div class="container max-height no-overflow">
	<div id="content" nevow:render="content">
		<h3>
 <a name="__index___socket"></a> <a name="__index___network_stack"></a> Network stack</h3>
<p>
One of the largest kernel subsystem is a network stack. It is called a <em>stack</em> because it consists from multiple protocols where each of them works on top of the more primitive protocol. That hierarchy is defined by different models such as <em>OSI model</em> or TCP/IP stack. When user data is passed through network, it is encapsulated into packets of that protocols: when data is passed to a protocol driver it puts some service data to the packet header and tail so operating system on receiver host can recognize them and build original message even when some data was lost or order of packets had changed during transmission. </p>
<p>
Each layer of network stack has its responsibilities so they are not of concern of higher-layer protocols. For example, IP allows to send datagrams through multiple routers and networks, can reassemble packets but doesn't guarantee reliability when some data is lost â€“- it is implemented in TCP protocol. Both of them can only transmit raw data, encoding or compression is implemented on higher layer like HTTP. </p>
<p>
Network subsystem (which transmits data between hosts) has a major difference over block input-output (which stores data): It is very sensitive to <em>latency</em>, so writing or reading data cannot be deferred. Due to that, sending and receiving is usually performed in the same thread context.</p>
<p>
Network stack in Unix systems can be split into three generic layers:
       <ul>
        <li>
 <em>Socket layer</em> which implements BSD sockets through series of system calls.
   </li>
        <li>
 Intermediate protocol drivers such as <em>ip</em>, <em>udp</em> and <em>tcp</em> and packet filters.
   </li>
        <li>
 Media Access Control (<em>MAC</em>) layer on the bottom which providing access to network interface cards (NICs) and <em>NIC API</em> itself. It is called <em>GLD</em> in Solaris.</li>
</ul>
</p>
<p>
<img src="../images/net.png" alt="image:net" class="img-rounded"></img></p>
<p>
  
<a name="__index___ring_buffer"></a> Network input-output can require transferring huge amounts of data, so it may be ineffective to explicitly send write commands for each packet. Instead of handling each packet individually, NIC and its driver maintain shared <em>ring buffer</em> where driver puts data while card uses <em>DMA</em> (direct memory access) mechanisms to read data and send it over network. Ring buffers are defined by two pointers: <em>head</em> and <em>tail</em>:</p>
<p>
<img src="../images/ringbuf.png" alt="image:ringbuf" class="img-rounded"></img></p>
<p>
When driver wants to queue packet for transmission it puts it into memory area of designated ring buffer and updates <em>tail</em> pointer appropriately. When NIC transfers data over a network it will update <em>head</em> pointer.</p>
<p>
Data structures are usually shared between stack layers. In Linux packets are represented by a generic <code>sk_buff</code> structure:</p>
<p>
<img src="../images/linux/net.png" alt="image:linux/net" class="img-rounded"></img></p>
<p>
That structure keeps two pointers: <code>head</code> and <code>data</code> and includes offsets for protocol headers. Data length is kept in <code>len</code> field, time stamp of packet in <code>tstamp</code> field. <code>sk_buff</code> structures form a doubly-linked list through <code>next</code> and <code>prev</code> structures. They refer network device descriptor which is represented by <code>net_device</code> structure and a socket which is represented by pair of structures: <code>socket</code> which holds generic socket data including file pointer which points to VFS node (sockets in Linux and Solaris are managed by special filesystems) and <code>sock</code> which keeps more network-related data including local address which is kept in <code>skc_rcv_saddr</code> and <code>skc_num</code> and peer address in <code>skc_daddr</code> and <code>skc_dport</code> correspondingly. </p>
<p>
Note that CPU byte order may differ from network byte order, so you should use conversion functions to work with addresses such as <code>ntohs</code>, <code>ntohl</code> or <code>ntohll</code> to convert to host byte order and <code>htons</code>, <code>htonl</code> and <code>htonll</code> for reverse conversions. They are provided both by SystemTap and DTrace and have same behaviour as their C ancestors.</p>
<p>
Here are sample script for tracing message receiving in Linux 3.9:
    <p>
    <pre>
# stap -e '
    probe kernel.function("tcp_v4_rcv") {
        printf("[%4s] %11s:%-5d -> %11s:%-5d len: %d\n",
            kernel_string($skb->dev->name),
                    
            ip_ntop($skb->sk->__sk_common->skc_daddr), 
            ntohs($skb->sk->__sk_common->skc_dport),
                    
            ip_ntop($skb->sk->__sk_common->skc_rcv_saddr), 
            $skb->sk->__sk_common->skc_num,
                    
            $skb->len);
    }'</pre>
</p>
</p>
<p>
Earlier versions of Linux (2.6.32 in this example) use different structure called <code>inet_sock</code>:
    <p>
    <pre>
# stap -e '
    probe kernel.function("tcp_v4_do_rcv") {
        printf("%11s:%-5d -> %11s:%-5d len: %d\n",
                ip_ntop(@cast($sk, "inet_sock")->daddr), 
                ntohs(@cast($sk, "inet_sock")->dport),
                    
                ip_ntop(@cast($sk, "inet_sock")->saddr), 
                ntohs(@cast($sk, "inet_sock")->sport),
                    
                $skb->len);
    }'</pre>
</p>
</p>
<p>
<a name="__index___STREAMS__Solaris_"></a> Solaris has derived <em>STREAMS</em> subsystem from System V which is intended to provide API for passing messages between multiple architectural layers which is perfectly fits to how network stack look like. Each message is represented by an <code>mblk_t</code> structure:</p>
<p>
<img src="../images/solaris/streams.png" alt="image:solaris/streams" class="img-rounded"></img></p>
<p>
Consumer reads data referred by <code>b_rptr</code> pointer while producer puts it under <code>b_wptr</code> pointer if there is enough space in allocated buffer (it is referred by <code>b_datap</code>) or allocates a new message and sets up forward and backward pointers <code>b_next</code> and <code>b_prev</code> so these messages form a doubly-linked list.</p>
<p>
Note that unlike <code>sk_buff</code> from Linux, these messages do not contain pointers to the management structure. Instead of doing that,  functions pass pointer to them as a separate argument which is usually first argument of the function (<code>arg0</code> in DTrace): <code>mac_impl_t</code> for MAC layer, <code>ill_t</code> for IP layer and <code>conn_t</code> for TCP/UDP protocols:</p>
<p>
<img src="../images/solaris/net.png" alt="image:solaris/net" class="img-rounded"></img></p>
<p>
Solaris wraps sockets into <code>sonode</code> structure which are handled by virtual file system called <em>sockfs</em>. <code>so_vnode</code> field in that structure points to VFS node. Like we mentioned before, TCP and UDP connection are managed by <code>conn_t</code> structure. It keeps addresses in <code>connua_laddr</code> and <code>connu_lport</code> fields for local address and uses <code>connua_faddr</code> and <code>connu_lport</code> for remote ports. Note that these names are different in Solaris 10. </p>
<p>
Here are example DTrace script for tracing message receiving in Solaris 11:
    <p>
    <pre>
# dtrace -n '
    tcp_input_data:entry {
        this->conn = (conn_t*) arg0;
        this->mp = (mblk_t*) arg1;
        
        printf("%11s:%-5d -> %11s:%-5d len: %d\n",
                inet_ntoa((ipaddr_t*) &(this->conn->connua_v6addr.
                                            connua_faddr._S6_un._S6_u32[3])),
                ntohs(this->conn->u_port.connu_ports.connu_fport),
                
                inet_ntoa((ipaddr_t*) &(this->conn->connua_v6addr.
                                            connua_laddr._S6_un._S6_u32[3])),
                ntohs(this->conn->u_port.connu_ports.connu_lport),
                
                (this->mp->b_wptr - this->mp->b_rptr));
    }'</pre>
</p>
</p>
<p>
<a name="__index___tcp__provider__Solaris_"></a> <a name="__index___ip__provider__Solaris_"></a> Solaris 11 introduced new providers for tracing network: <code>tcp</code>, <code>udp</code> and <code>ip</code>. Here are probes that are provided by them and their siblings from Linux and SystemTap:</p>
<p>
    <table class="table table-bordered" style="width: 100%">
        <tr>
            <td>
<em>Action</em> </td>
            <td>
 <em>DTrace</em> </td>
            <td>
 <em>SystemTap</em></td>
</tr>
        <tr>

            <td  colspan="3">
 <strong>TCP</strong></td>
</tr>
        <tr>

            <td>
Connection to remote node </td>
            <td>
 
    <code>tcp:::connect-request</code>     <br /> 
    <code>tcp:::connect-established</code> <br /> 
    <code>tcp:::connect-refused</code>       </td>
            <td>
 
    <code>kernel.function("tcp_v4_connect")</code></td>
</tr>
        <tr>

            <td>
Accepting remote connection </td>
            <td>
 
    <code>tcp:::accept-established</code> <br /> 
    <code>tcp:::accept-refused</code>      </td>
            <td>
 
    <code>kernel.function("tcp_v4_hnd_req")</code></td>
</tr>
        <tr>

            <td>
Disconnecting               </td>
            <td>
 
    <code>fbt:::tcp_disconnect</code>      </td>
            <td>
 
    <code>tcp.disconnect</code></td>
</tr>
        <tr>

            <td>
State change                </td>
            <td>
 
    <code>tcp::state-change</code>         </td>
            <td>
 
    -</td>
</tr>
        <tr>

            <td>
Transmission                </td>
            <td>
 
    <code>tcp:::send</code>                </td>
            <td>
 
    <code>tcp.sendmsg</code></td>
</tr>
        <tr>

            <td>
Receiving                   </td>
            <td>
 
    <code>tcp:::receive</code>             </td>
            <td>
 
    <code>tcp.receive</code>              <br />
    <code>tcp.recvmsg</code></td>
</tr>
        <tr>

            <td  colspan="3">
 <strong>IP</strong></td>
</tr>
        <tr>

            <td>
Transmission                </td>
            <td>
 
    <code>ip:::send</code>                 </td>
            <td>
 
    <code>kernel.function("ip_output")</code></td>
</tr>
        <tr>

            <td>
Receiving                   </td>
            <td>
 
    <code>ip:::receive</code>              </td>
            <td>
 
    <code>kernel.function("ip_rcv")</code></td>
</tr>
        <tr>

            <td  colspan="3">
 <strong>Network device</strong></td>
</tr>
        <tr>

            <td>
Transmission                </td>
            <td>
 
    <code>mac_tx:entry</code>, or function from NIC driver like <code>e1000g_send:entry</code>  </td>
            <td>
 
    <code>netdev.transmit</code>          <br />
    <code>netdev.hard_transmit</code></td>
</tr>
        <tr>

            <td>
Receiving                   </td>
            <td>
 
    <code>mac_rx_common:entry</code>, or function from NIC driver like <code>e1000g_receive:entry</code>  </td>
            <td>
 
    <code>netdev.rx</code></td>
</tr>
</table>
</p>
<p>
Sockets can be traced using syscall tracing. SystemTap provides special tapset <code>socket</code> for that.</p>
<p>
Both Linux and Solaris provide various network statistics which are provided by SNMP and accessible through <code>netstat -s</code> command. Many events registered by these counters are implemented using <code>mib</code> provider from DTrace or <code>tcpmib</code>, <code>ipmib</code> and <code>linuxmib</code> tapsets in SystemTap, but they do not have connection-specific data.
</p>

	</div>
</div>

<!-- TAIL -->

<div class="navbar navbar-bottom">
    <div class="navbar-inner">
        <div class="container">
            <ul class="nav pull-left">
<li><a href="ex5.html"><strong>Prev</strong>(Exercise 5)</a></li>
</ul>
<ul class="nav pull-center">
<li><a href="../index.html"><strong>Up</strong>(Dynamic Tracing with DTrace & SystemTap)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="sobj.html"><strong>Next</strong>(Synchronization primitives)</a></li>
</ul>
        </div>
    </div>
</div>

<ul class="breadcrumb">
    <li><a href="https://github.com/myaut/dtrace-stap-book"><small>GitHub</small></a> <span class="divider">|</span></li>
    <li><a href="https://bitbucket.org/sergey_klyaus/dtrace-stap-book"><small>BitBucket</small></a> <span class="divider">|</span></li>
    <li style="float: right; ">
        <small>
        Published under terms of <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC-BY-NC-SA 3.0</a> license.
        </small>
    </li>
</ul>
</body>
</html>