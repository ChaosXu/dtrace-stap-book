<html>
<head>
	<meta charset="utf-8" /> 
	<meta http-equiv="Content-Type" content="text/html">
	<meta name="generator" content="TSDoc 0.2">
	
	<title>Module 4: Operating system kernel tracing</title>
	
	<link rel="stylesheet" href="../bootstrap/css/bootstrap.css" />
	<link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet" />
	
	<script type="text/javascript">
	function toggleCode(id) {
		code = document.getElementById(id);
		hideClass = 'hide';
		
		if(code.classList.contains(hideClass))
			code.classList.remove(hideClass);
		else
			code.classList.add(hideClass);
	}
	</script>
</head>
<body>

<!-- HEADER -->

<div class="navbar">
    <div class="navbar-inner">
	    <div class="container">
			<a class="brand" href="../index.html">Dynamic Tracing with DTrace & SystemTap</a><ul class="nav pull-left">
<li><a href="bio.html"><strong>Prev</strong>(Block Input-Output)</a></li>
</ul>
		</div>
    </div>
</div>

<div class="container max-height no-overflow">
	<div id="content" nevow:render="content">
		<p>
<h3>Asynchronicity in kernel</h3></p>
<p>
Let's return to our scripts, <code>scsitrace.stp</code> and <code>sdtrace.d</code> which we had introduced in previous section, <a href="bio.html">Block Input-Output</a>. We tested it with block I/O. If we create a filesystem on block device and try to write to it, we will see some interesting names of processes which actually perform the write. I.e. on Solaris:<br /></p>
<p>
<pre>
PROC: 5/15 zpool-tiger
</pre>
</p>
<p>
or on Linux:<br /></p>
<p>
<pre>
PROC: 643/643 flush-8:0
</pre>
</p>
<p>
This is internal system process which is not related to a process which is actually initiated <code>write()</code> call.<br /></p>
<p>
This is called an <em>asynchronicity</em>, a common kernel idiom when requests are kept in queues and being flushed to receiver at an unspecified moment of time (i.e. when device is ready, when we collected batch of adjacent requests, etc.). That <em>flush</em> is performed by separate kernel process (note how it is named in Linux) which has its own context. In our example <code>write()</code> system call won't actually start block input-output but updates page in page cache making it dirty (incorrect ZFS as it actually queues ZIO operation). Then <em>writeback</em> mechanism in Linux or <em>fsflush</em> daemon in Solaris is awoken. They walk dirty pages in page cache and write them back to stable storage. Finally, when disk finishes requested operation, bus driver will generate an interrupt which will create three independent contexts where request was handled:<br /></p>
<p>
<img src="../images/aio.png" alt="" /></p>
<p>
This makes thread-local variables useless for such cases.<br /></p>
<p>
To overcome this situation we can use associative arrays, but instead of using process ID or thread ID we have to use something stable for a whole request execution. We can save PID using that key and then access it from interrupt probe by using same key and print it.<br /></p>
<p>
In our example it would be address of page in Linux:<br /></p>
<p>
<pre>
# stap -e '
    global pids;
    
    probe module("ext4").function("ext4_*_write_end"),
            module("xfs").function("xfs_vm_writepage") {
        page = $page;
        pids[page] = pid();

        printf("I/O initiated pid: %d page: %p %d\n", 
            pid(), $page, gettimeofday_ns());
    }

    probe ioblock.request {
        if($bio == 0 || $bio->bi_io_vec == 0)
            next;
        page = $bio->bi_io_vec[0]->bv_page;
    
        printf("I/O started pid: %d real pid: %d page: %p %d\n", 
                pid(), pids[page], page, gettimeofday_ns());
    } '
â€¦
I/O initiated pid: 2975 page: <b>0xffffea00010d4d40</b> 1376926650907810430
I/O initiated pid: 2975 page: 0xffffea00010d1888 1376926650908267664
I/O started pid: 665 real pid: 2975 page: <b>0xffffea00010d4d40</b> 1376926681933631892
</pre>
</p>
<p>
Note that despite the fact that process IDs in filesystem and block I/O probe are different, address of <code>page</code> structure is stable here.<br /></p>
<p>
Same works for Solaris -- we can rely on <code>dbuf</code> pointer which represents a <em>dnode buffer</em>:<br /></p>
<p>
<pre>
# dtrace -n '
    dbuf_dirty:entry { 
        pids[(uintptr_t) arg0] = pid; 
        printf("I/O initiated pid: %d dbuf: %p %d", 
            pid, arg0, timestamp);
    }

    dbuf_write:entry { 
        this->db = args[0]->dr_dbuf; 
        printf("I/O started pid: %d real pid: %d dbuf: %p %d", 
            pid, pids[(uintptr_t) this->db], this->db,
            timestamp);
    } '
</pre>
</p>
<p>
This technique is usually used <em>request extraction</em> -- in ideal case we could observe all request handling from user clicking in a browser through network I/O, processing in web server, accessing database and, eventually, block I/O caused by that. <br /></p>
<p>
Modern kernels have low-level primitives for building such asynchronous mechanisms. We will discuss some of them later.</p>

	</div>
</div>

<!-- TAIL -->

<div class="navbar">
    <div class="navbar-inner">
        <div class="container">
            <ul class="nav pull-left">
<li><a href="bio.html"><strong>Prev</strong>(Block Input-Output)</a></li>
</ul>
<ul class="nav pull-center">
<li><a href="../index.html"><strong>Up</strong>(Dynamic Tracing with DTrace & SystemTap)</a></li>
</ul>
        </div>
    </div>
</div>

</body>
</html>