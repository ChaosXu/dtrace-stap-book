<html>
<head>
	<meta charset="utf-8" /> 
	<meta http-equiv="Content-Type" content="text/html">
	<meta name="generator" content="TSDoc 0.2">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<title> Module 2: Dynamic tracing languages
</title>
	
	<link rel="stylesheet" href="../bootstrap/css/bootstrap.css" />
	<link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet" media="screen,handheld"/>
	
	<script type="text/javascript">
	function toggleCode(id) {
		code = document.getElementById(id);
		hideClass = 'hide';
		
		if(code.classList.contains(hideClass))
			code.classList.remove(hideClass);
		else
			code.classList.add(hideClass);
	}
	</script>
	
	<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-71659121-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>
<body>

<!-- HEADER -->

<div class="navbar">
    <div class="navbar-inner">
	    <div class="container">
			<a class="brand" href="../index.html">Dynamic Tracing with DTrace & SystemTap</a><ul class="nav pull-left">
<li><a href="predicates.html"><strong>Prev</strong>(Predicates)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="pointers.html"><strong>Next</strong>(Pointers)</a></li>
</ul>
		</div>
    </div>
</div>

<div class="container max-height no-overflow">
	<div id="content" nevow:render="content">
		<h3>
 Types and Variables</h3>
<p>
In this section we will speak about typing in dynamic tracing languages and variable scopes. Details on complex types are covered in further sections.</p>
<p>
Variable types may be split in several categories. First and simpler one, is <strong>scalar types</strong> which consist of integral types: <code>int</code>, <code>uint32_t</code>, etc, floating point types are not supported. Second large group is <strong>pointers</strong>. Unlike C, dynamic tracing languages provide explicit <strong>string</strong> type. SystemTap and DTrace support <strong>associative arrays</strong> and <strong>agreggations</strong> for keeping statistics data. Finally, there is a set of <strong>complex</strong> types such as structures, enumerations, unions and arrays. DTrace supports complex types, their definitions and even aliasing through <code>typedef</code>, while in SystemTap they are implicitly used for DWARF variables, but in scripts they are explicitly available only in Embedded C.</p>
<p>
You can explicitly declare variable types in DTrace, thus <code>long</code>, <code>uintptr_t</code>, <code>string</code>, etc. are valid identifiers in it, but it is optional for non-global variables. In SystemTap, there are only two primitive types: <code>long</code> for keeping any scalar integral type or pointer, and <code>string</code> for strings. Types are explicitly specified only as return values of functions or function arguments. If types are not specified, then they are deduced from first assignment, but dynamic typing is disallowed: in case of type incompatibility error <code>operands have incompatible types</code> or <code>type mismatch</code> will be printed. DTrace also supports C-style type casting:
    <p>
    <pre>
printf("The time is %lld\n", (unsigned long long) timestamp);</pre>
</p>
</p>
<p>
There are four variable scopes in DTrace: external, global, local and thread-local. SystemTap doesn't support thread-local variables, but it can be emulated via associative arrays.</p>
<p>
<img src="../images/varscope.png" alt="" class="img-rounded"/></p>
<p>
In this image variable lifetimes are shown as arrows on the right of the drawing. </p>
<p>
    <h4>
 External variables</h4>
</p>
<p>
External variables are exported by kernel or application, for example tunable module parameters, thus they have longest lifespan that goes beyond running tracing scripts. In DTrace external variables are kept in separate namespace, and accessible with backtick (<code>`</code>) prefix:
    <p>
    <pre>
# dtrace -qn '
    BEGIN { 
        printf("Maximum pid is %d\n", `pidmax ); 
        exit(0); }'</pre>
</p>
</p>
<p>
In earlier versions of SystemTap they can be only read by using Embedded C capabilities:
    <p>
    <pre>
# stap -g -e '
    function get_jiffies:long() %{
        THIS->__retvalue = jiffies;    %}
    probe timer.us(400) {
        printf("The time is %d jiffies\n", 
            get_jiffies());            }'</pre>
</p>
</p>
<p>
Recent versions adopted a <code>@var</code>-expression, which accept name of variable and optionally a path to a source file where it is located like in function probes: <code>@var("jiffies")</code>. </p>
<p>
    <h4>
 Global variables</h4>
</p>
<p>
Global variables are created on script start and destroyed when script finishes their execution. They are often initialized by begin probes and sometimes printed in the end probe. In SystemTap global variables are declared with <code>global</code> keyword:
    <p>
    <pre>
global somevar;</pre>
</p>
</p>
<p>
You can also put an initializer to a global variable, thus it is useful to simulate constants and enumerations:
    <p>
    <pre>
global READ = 1;</pre>
</p>
</p>
<p>
Global variables in DTrace may be declared with type keyword, but that is optional:
    <p>
    <pre>
uint32_t globalvar;</pre>
</p>

Aggregations in DTrace are implicitly global.</p>
<p>
Global variables in probes are accessible by their names: <code>globalvar += 1;</code>.</p>
<p>
    <h4>
 Local variables</h4>
</p>
<p>
Local (or <em>clause-local</em> in terms of DTrace) variables lifespan are the shortest of all which last only for single probe, or for a probe-prologue followed by probe in SystemTap. There is no need to define them in SystemTap, they may be used after first assignment:
    <p>
    <pre>
probe kernel.function("vfs_write") {
    pos = $file->f_pos;
}</pre>
</p>
</p>
<p>
In DTrace, their types may be optionally defined with <code>this</code> keyword, and later used with <code>this-&gt;</code> prefix:</p>
<p>
    <p>
    <pre>
this uint32_t localvar;

::write:entry {
    this->localvar = (uint32_t) arg0;
}</pre>
</p>
</p>
<p>
<span class="label label-warning">Warning</span>    <div class="well">
        <p>
DTrace doesn't check scopes for local variables nor initialize it with zero, thus allowing racing conditions. Take the following script as an example, which counts the number of <code>read()</code> system calls:</p>
        <p>
            <p>
            <pre>
int global;
this int local;

syscall::read:entry {
    this->local++;
    global++; 
}
syscall::read:return {
    printf("local: %d global: %d\n", this->local, global); 
}</pre>
</p>
</p>
        <p>
If you run this script in parallel with single <code>dd</code> process, everything will look fine:
            <p>
            <pre>
# dtrace -qs clauselocal.d -c "dd if=/dev/zero of=/dev/null"
[...]
local: 26765 global: 26765
[...]</pre>
</p>
</p>
        <p>
But when you run multiple <code>dd</code> processes, local and global numbers will eventually differ, because in case of race condition, new space will be allocated:</p>
        <p>
<img src="../images/localglobal.png" alt="" class="img-rounded"/></p>
        <p>
</p>
</div>
</p>
<p>
<a name="thread-local-vars"></a>
    <h4>
 Thread-local variables</h4>
</p>
<p>
Thread local variables are created in a context of a thread, and after thread is switched, you will access a new instance of variable. Their syntax is similar to local DTrace variables, but use <code>self</code> keyword instead of <code>this</code>. They are extremely useful in passing data between distinct probes:</p>
<p>
    <p>
    <pre>
self int readfd; // Optional

syscall::read:entry {
    self->readfd = arg0;
}
syscall::read:return {
    printf("read %d --> %d\n", self->readfd, arg1);
}</pre>
</p>
</p>
<p>
Thread-local variables are not supported by SystemTap but may be easily simulated with associative array whose key is a thread ID:
    <p>
    <pre>
global readfd;
syscall.read {
    readfd[tid()] = fd;
}
syscall.read.return {
    printf("read %d --> %d\n", readfd[tid()], $return);
}</pre>
</p>
</p>
<p>
Other use-case for thread-local variables is when you want to trace only processes that did certain actions, and filter others. In this case, you will introduce a kind of thread-local <code>do_trace</code> flag, which will be set to 1 if action was done (and probably, reset later), and later check this flag in predicate. If value is not set in associative array in SystemTap or as thread-local variable in DTrace, it defaults to 0, which by default disables probes. This approach is idiomatic, and for example used in <a href="../principles/dyncode.html">Dynamic code analysis</a> for building code graphs. </p>
<p>
    <h4>
 References</h4>
</p>
<p>
     <ul>
        <li>
 <img src="../images/icons/dtrace.png" alt=" " class="img-rounded"/> <a href="http://docs.oracle.com/cd/E19253-01/817-6223/chp-variables/index.html">Variables</a>
 </li>
        <li>
 <img src="../images/icons/staplang.png" alt=" " class="img-rounded"/> <a href="https://sourceware.org/systemtap/langref/Language_elements.html#SECTION00062000000000000000">Data types</a>
 </li>
        <li>
 <img src="../images/icons/staplang.png" alt=" " class="img-rounded"/> <a href="https://sourceware.org/systemtap/langref/Components_SystemTap_script.html#SECTION00043000000000000000">Variables</a>
</li>
</ul>
</p>

	</div>
</div>

<!-- TAIL -->

<div class="navbar navbar-bottom">
    <div class="navbar-inner">
        <div class="container">
            <ul class="nav pull-left">
<li><a href="predicates.html"><strong>Prev</strong>(Predicates)</a></li>
</ul>
<ul class="nav pull-center">
<li><a href="../index.html"><strong>Up</strong>(Dynamic Tracing with DTrace & SystemTap)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="pointers.html"><strong>Next</strong>(Pointers)</a></li>
</ul>
        </div>
    </div>
</div>

<ul class="breadcrumb">
    <li><a href="https://github.com/myaut/dtrace-stap-book"><small>GitHub</small></a> <span class="divider">|</span></li>
    <li><a href="https://bitbucket.org/sergey_klyaus/dtrace-stap-book"><small>BitBucket</small></a> <span class="divider">|</span></li>
    <li style="float: right; ">
        <small>
        Published under terms of <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC-BY-NC-SA 3.0</a> license.
        </small>
    </li>
</ul>
</body>
</html>