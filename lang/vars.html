<html>
<head>
	<meta charset="utf-8" /> 
	<meta http-equiv="Content-Type" content="text/html">
	<meta name="generator" content="TSDoc 0.2">
	
	<title>Module 2: Dynamic tracing languages</title>
	
	<link rel="stylesheet" href="../bootstrap/css/bootstrap.css" />
	<link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet" />
	
	<script type="text/javascript">
	function toggleCode(id) {
		code = document.getElementById(id);
		hideClass = 'hide';
		
		if(code.classList.contains(hideClass))
			code.classList.remove(hideClass);
		else
			code.classList.add(hideClass);
	}
	</script>
</head>
<body>

<!-- HEADER -->

<div class="navbar">
    <div class="navbar-inner">
	    <div class="container">
			<a class="brand" href="../index.html">Dynamic Tracing with DTrace & SystemTap</a><ul class="nav pull-left">
<li><a href="predicates.html"><strong>Prev</strong>(Predicates)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="pointers.html"><strong>Next</strong>(Pointers)</a></li>
</ul>
		</div>
    </div>
</div>

<div class="container max-height no-overflow">
	<div id="content" nevow:render="content">
		<p>
<h3>Types and Variables</h3></p>
<p>
In this section we will speak about typing in dynamic tracing languages and variable scopes. Details on how complex types are covered in further sections.<br /></p>
<p>
Variable types may be split in several categories. First and simpler one, is <strong>scalar types</strong> which consist of integral types: <code>int</code>, <code>uint32_t</code>, etc, floating point types are not supported. Second large group is <strong>pointers</strong>. Unlike C, dynamic tracing languages provide explicit <strong>string</strong> type. SystemTap and DTrace support <strong>associative arrays</strong> and <strong>agreggations</strong> for keeping statistics data. Finally, there is a set of <strong>complex</strong> types such as structures, enumerations, unions and arrays. DTrace supports complex types, their definitions and even aliasing through <code>typedef</code>, in SystemTap they are implicitly used for DWARF variables, but in scripts they explicitly available only in Embedded C.<br /></p>
<p>
You can explicitly declare variable types in DTrace, thus <code>long</code>, <code>uintptr_t</code>, <code>string</code>, etc. are valid identifiers in it, but it is optional for non-global variables. In SystemTap, there are only two primitive types: <code>long</code> for keeping any scalar integral type or pointer or <code>string</code> for strings. Types explicitly specified only as return values of functions or function arguments. If types are not specified, than they are deduced from first assignment, but dynamic typing is disallowed: in case of type incompatibility error <code>operands have incompatible types</code> or <code>type mismatch</code> will be printed. DTrace also supports C-style type casting:<br /></p>
<p>
<pre>
printf("The time is %lld\n", (unsigned long long) timestamp);
</pre>
</p>
<p>
There are four variable scopes in DTrace: external, global, local and thread-local. SystemTap doesn't support thread-local variables, but in can be emulated via associative arrays.<br /></p>
<p>
<img src="../images/varscope.png" alt="" /></p>
<p>
In this image variable lifetimes are shown as arrows on the right of the drawing. <br /></p>
<p>
<h4>External variables</h4></p>
<p>
External variables are exported by kernel or application, for example tunable module parameters, thus they have longest lifespan that goes beyond running tracing scripts. In DTrace external variables are kept in separate namespace, and accessible with backtick (<code> ` </code>) prefix:<br /></p>
<p>
<pre>
# dtrace -qn '
    BEGIN { 
        printf("Maximum pid is %d\n", `pidmax ); 
        exit(0); }'
</pre>
</p>
<p>
In earlier versions of SystemTap they can be only read by using Embedded C capabilities:<br /></p>
<p>
<pre>
# stap -g -e '
    function get_jiffies:long() %{
        THIS->__retvalue = jiffies;    %}
    probe timer.us(400) {
        printf("The time is %d jiffies\n", 
            get_jiffies());            }'
</pre>
</p>
<p>
Recent versions adopted a <code>@var</code>-expression, which accept name of variable and optionally a path to a source file where it is located like in function probes: <code>@var("jiffies")</code>. <br /></p>
<p>
<h4>Global variables</h4></p>
<p>
Global variables are created on script start and destroyed when script finishes their execution. They are often initialized by begin probes and sometimes printed in the end probe. In SystemTap global variables are declared with <code>global</code> keyword:<br /></p>
<p>
<pre>
global somevar;
</pre>
</p>
<p>
You can also put an initializer to a global variable, thus it is useful to simulate constants and enumerations:<br /></p>
<p>
<pre>
global READ = 1;
</pre>
</p>
<p>
Global variables in DTrace may be declared with type keyword, but that is optional:<br /></p>
<p>
<pre>
uint32_t globalvar;
</pre>
</p>
<p>
Aggregations in DTrace are implicitly global.<br /></p>
<p>
Global variables in probes accessible by their names: <code>globalvar += 1;</code>.<br /></p>
<p>
<h4>Local variables</h4></p>
<p>
Local (or <em>clause-local</em> in terms of DTrace) variables lifespan are the shorter of all which lasts only for single probe, or for a probe-prologue followed by probe in SystemTap. There is no need to define them in SystemTap, they may be used after first assignment:<br /></p>
<p>
<pre>
probe kernel.function("vfs_write") {
    pos = $file->f_pos;
}
</pre>
</p>
<p>
In DTrace, their types may be optionally defined with <code>this</code> keyword, and later used with <code>this-&gt;</code> prefix:<br /></p>
<p>
<pre>
this uint32_t localvar;

::write:entry {
    this->localvar = (uint32_t) arg0;
}
</pre>
</p>
<span class="label label-warning">Warning</span><div class="well">
DTrace doesn't check scopes for local variables and doesn't initialize it with zero, thus allowing racing conditions. Take for example this script which counts number of <code>read()</code> system calls:<br />    <p>
    <pre>
int global;
this int local;

syscall::read:entry {
    this->local++;
    global++; 
}
syscall::read:return {
    printf("local: %d global: %d\n", this->local, global); 
}
</pre>
</p>
If you run this script in parallel with single <code>dd</code> process, everything will look fine:<br />    <p>
    <pre>
# dtrace -qs clauselocal.d -c "dd if=/dev/zero of=/dev/null"
[...]
local: 26765 global: 26765
[...]
</pre>
</p>
But when you run multiple <code>dd</code> processes, local and global numbers will eventually differ, because in case of race condition, new space will be allocated:<br /><img src="../images/localglobal.png" alt=" processes, local and global numbers will eventually differ, because in case of race condition, new space will be allocated:<br />" /></div>
<p>
<a name="thread-local-vars"></a><h4>Thread-local variables</h4></p>
<p>
Thread local variables are created in a context of a thread, and after thread will be switched, you will access new instance of variable. Their syntax is similar to local DTrace variables, but use <code>self</code> keyword instead of <code>this</code>. They are extremely useful in passing data between distinct probes:<br /></p>
<p>
<pre>
self int readfd; // Optional

syscall::read:entry {
    self->readfd = arg0;
}
syscall::read:return {
    printf("read %d --> %d\n", self->readfd, arg1);
}
</pre>
</p>
<p>
Thread-local variables are not supported by SystemTap but may be easily simulated with associative array which key is a thread ID:<br /></p>
<p>
<pre>
global readfd;
syscall.read {
    readfd[tid()] = fd;
}
syscall.read.return {
    printf("read %d --> %d\n", readfd[tid()], $return);
}
</pre>
</p>
<p>
Other use-case for thread-local variables is when you want to trace only processes that did certain actions, and filter others. In this cases, you will introduce a kind of thread-local <code>do_trace</code> flag, which will be set to 1 if action was done (and probably, reset later), and later check this flag in predicate. If value is not set in associative array in SystemTap or as thread-local variable in DTrace, it defaults to 0, which by default disables probes. This approach is idiomatic, and for example used in <a href="../principles/dyncode.html">Dynamic code analysis</a> for building code graphs. <br /></p>
<p>
<h4>References</h4></p>
<p>
    <ul>
        <li>
<img src="../images/icons/dtrace.png" alt="" /><a href="http://docs.oracle.com/cd/E19253-01/817-6223/chp-variables/index.html">Variables</a></li>
        <li>
<img src="../images/icons/staplang.png" alt="" /><a href="https://sourceware.org/systemtap/langref/Language_elements.html#SECTION00062000000000000000">Data types</a></li>
        <li>
<img src="../images/icons/staplang.png" alt="" /><a href="https://sourceware.org/systemtap/langref/Components_SystemTap_script.html#SECTION00043000000000000000">Variables</a></li>
</ul>
</p>

	</div>
</div>

<!-- TAIL -->

<div class="navbar">
    <div class="navbar-inner">
        <div class="container">
            <ul class="nav pull-left">
<li><a href="predicates.html"><strong>Prev</strong>(Predicates)</a></li>
</ul>
<ul class="nav pull-center">
<li><a href="../index.html"><strong>Up</strong>(Dynamic Tracing with DTrace & SystemTap)</a></li>
</ul>
<ul class="nav pull-right">
<li><a href="pointers.html"><strong>Next</strong>(Pointers)</a></li>
</ul>
        </div>
    </div>
</div>

</body>
</html>